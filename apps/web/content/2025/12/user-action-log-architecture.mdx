---
title: "CS의 시간을 1/10로 줄이는 사용자 행동 로그(User Action Log)"
date: "2025-12-29"
description: "로그 하나 남기려다 개발 흐름 다 끊기던 시절의 삽질 기록. CS 팀의 야근을 줄이기 위해 Go 기반 트랜잭셔널 로깅 시스템을 구축하며 겪은 고민과 실수들을 담백하게 정리했습니다."
tags: ["Golang", "Log", "Architecture"]
draft: true
---

개발자로 일하다 보면 **"이걸 진짜 내가 해야 해?"** 싶은 순간들이 온다. 1년 전, 신규 프로젝트를 맡았을 때가 딱 그랬다.

"유저가 뭘 했는지 로그 좀 남겨주세요."
"네, 테이블 명세서 주시면 만들게요."

단순히 시스템 로그(`fmt.Println`)가 아니다. 유저의 자산과 행동을 추적하는 **'사용자 행동 로그(User Action Log)'** 이야기다. 오늘은 CS 팀의 시간을 1/10로 줄이고, 우리 개발팀의 야근도 줄여준 **Go 기반의 로깅 아키텍처**를 구축하며 했던 삽질들을 기록해 본다.

## 문제: 로그가 일을 만든다

게임 서버에서 유저 행위 로그를 남기는 건 생각보다 귀찮은 일이다.
"상점에서 패키지를 샀다"는 행위 하나만 해도 내부적으로 할 일이 많다.

*   **상품 구매**: 구매 이력 남겨야 함
*   **재화 소모**: 차감된 골드 내역 남겨야 함
*   **아이템 획득**: 들어온 아이템 기록해야 함
*   **우편 발송**: 인벤토리 꽉 차서 우편 갔으면 그것도 남겨야 함
*   **퀘스트**: 이걸로 퀘스트 깼으면 그것도...

처음엔 별생각 없이 **"하던 대로 하자"** 고 생각했다. 각 행위마다 테이블 만들고, Insert 쿼리 날리고.
그런데 막상 설계를 시작해 보니 견적이 안 나왔다.

**"개발자가 이거 구현하느라 일 다 하겠는데?"**

새 로그 하나 추가할 때마다 `기획 -> 테이블 생성 -> 프로시저 작성 -> 코드 수정` 사이클을 돌아야 한다.
신규 프로젝트라 기능 개발하기도 바쁜데, 로그 때문에 개발 속도가 반토막 날 판이었다.

## 상황: 우리는 인프라 팀이 아니다

당시 우리 팀의 상황은 좀 특수했다.
*   **팀 구성의 특수성**: 팀원 대다수가 클라이언트 개발자 출신이었다. 서버 로직도 같이 짜야 하는 풀스택 환경이었는데, 이들에게 복잡한 테이블 관리나 인프라 작업을 요구하는 건 무리였다.
*   **빠른 개발 속도**: 신규 프로젝트 특성상 요구사항이 매일 바뀌는데, 로그 스키마도 같이 바꿔야 한다면? 끔찍하다.
*   **작업 흐름의 비효율성**: DB 성능이나 비용 이전에, 그냥 **작업 흐름 자체가 너무 비효율적**이었다.

결론은 하나였다.
**"개발자는 '무엇을' 남길지만 고민하게 하자. 나머지는 알아서 되게 만들자."**

## 접근: 트랜잭션 흉내 내기

고민 끝에 로그를 **DB 트랜잭션(Transaction)** 처럼 다루기로 했다.

요청이 들어와서 끝날 때까지 발생한 모든 로그를 메모리 어딘가에 **임시로 쌓아두고(Buffer)**,
로직이 성공적으로 끝나면 그때 **한 번에 발송(Flush)** 하는 전략이다.

### 아키텍처: 문맥(Context) 챙기기

우리 서버는 WebSocket 기반이었지만, HTTP 서버처럼 계층 구조(Layered Architecture)를 잡았다.

<ContextArchitectureFlow />

핵심은 **RPC Parser**다. 패킷이 오면 RPC Command와 RequestID, 요청 시각, 유저정보(UserID, 국가 등)를 **Context**에 담아서 전달한다. 

```go
// RPC Parser Layer
func (parser *Parser) HandlePacket(conn *Connection, packet *Packet) {
    // 1. 요청마다 고유 ID 발급
    reqID := uuid.New()
    
    // 2. PeerContext 생성 (여기에 다 때려 넣는다)
    peerCtx := context.NewPeerContext(conn, packet)
    
    // 3. 로직 수행
    parser.router.Serve(peerCtx)
}
```

이제 개발자가 어디서 로그를 찍든, 이 `PeerContext`만 있으면 "누가, 언제, 무슨 요청으로" 한 짓인지 자동으로 기록된다.

## 구현: High Level API

우리 팀 클라이언트 개발자분들에게 복잡한 내부 사정을 알 필요 없이, 운영과 기획팀에서 제시하는 로그를 기록하기 위해 단 두개의 API를 사용하도록 가이드 했다.

### ctx.AppendLog(data)

로그를 어딘가로 보내지 않는다. 그냥 `PeerContext` 메모리 버퍼에 `append` 할 뿐이다.

```go
// 비즈니스 로직
func (service *PurchaseService) PurchaseProduct(ctx *PeerContext, product Product) error {
    // 상품 구매 로직...
    
    // 상품 구매 로그
    ctx.AppendLog(PurchaseProductLog{
        PID: product.ID,
        Price: product.Price,
        Quantity: 1,
        TotalPrice: product.Price,
        Currency: "KRW",
    })
    
    return nil
}
```

### ctx.WriteLog()

중요한 로그의 경우 임시 버퍼에 담지 않고, 즉시 발송이 필요한 경우 사용한다. 

## 최적화: 쏘고 잊어라 (Fire and Forget)

로그 남기느라 게임 서버 렉 걸리면 그게 더 문제다. 그래서 철저하게 비동기로 풀었다. 

1.  **Memory Queue**: Go Channel에 로그를 던지고 바로 리턴한다.
2.  **Batch Worker**: 백그라운드 워커가 채널 내용을 모아서(Batch) 일정 갯수 마다 혹은 일정 시간 간격으로 로그를 발송한다.
3.  **Destination**: 목적지는 RDB가 아니라 **Naver Cloud ELAS(Effective Log Search & Analytics)** 였다. 스키마 없이 JSON 던지면 알아서 인덱싱해 주니 세상 편하다.

<FinalArchitectureFlow />

## 야근이 줄었다

거창한 기술 쓴 건 아니지만, 효과는 확실했다.

1.  **개발 속도**: "로그 테이블 만들어주세요" 요청이 사라졌다. 그냥 코드에 `AppendLog` 한 줄 넣으면 끝이다.
2.  **CS 대응**: 파편화됐던 로그들이 `RequestID` 하나로 묶이니, CS 담당자가 검색 한 방에 유저 행적을 파악한다. "이거 왜 안 들어왔죠?" 하면 "아, 그때 인벤 꽉 차서 우편 갔네요." 바로 나온다.

물론 아쉬움도 남는다. 재시도 실패 시 로그 유실 가능성을 열어둔 점이나, 표준 Tracing(OpenTelemetry) 도입을 미룬 점 등등.
그래도 <strong>"팀의 현재 상황에 맞춰 가장 효율적인 답을 찾았다"</strong>는 점에서는 꽤 만족스러운 프로젝트였다. 기술적으로 완벽한 것보다, 우리 팀이 쓰기 편한 게 최고니까.

### 안일했던 에러 처리

여기서 한 가지 **부끄러운 고백**을 하자면, 실패 처리를 너무 나이브(Naive)하게 했다.

배치 발송이 실패하면 재시도(Retry)는 한다. 그런데 재시도도 실패하면?
**그냥 버렸다.** (Drop)

"에이, 재시도까지 터질 정도면 어차피 답 없는 상황 아니야?"
당시엔 그렇게 합리화했다. 별도의 Dead Letter Queue(DLQ)나 파일 백업 로직을 넣지 않았다. 서비스 오픈 초기 로그가 폭발적으로 발생하면서, 네트워크 트래픽 제한으로 일부 로그가 재시도 마저 실패하여 유실되었다. 

지금 생각해보면 임시로 인메모리 환경에서 사용 가능한 sqlite와 같은 데이터베이스에 발송 대기 중인 로그를 임시로 저장하고, 파일로 백업하는 것도 좋은 방법이 아닐까 생각한다.

