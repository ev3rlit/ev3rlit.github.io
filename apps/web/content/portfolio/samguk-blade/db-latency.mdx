---
title: "DB 레이턴시 최적화"
description: "인메모리 트랜잭션 구조로 API 응답 시간 10배 개선"
project: "samguk-blade"
projectTitle: "삼국 블레이드 키우기"
tags: ["Performance", "Database", "Caching"]
order: 2
---

## TL;DR

컨텐츠 추가 과정에서 API 응답 지연 징후를 발견했습니다. 매 요청마다 DB에 접근하는 구조가 원인이었고, **인메모리 트랜잭션 데이터 구조**와 **Write-back 동기화**로 응답 시간을 **50ms → 5ms**로 10배 개선했습니다.

---

## 배경

서버 구조가 안정화된 후 컨텐츠를 추가하는 과정에서 이상 징후를 발견했습니다.

- API 응답이 점점 느려지는 패턴
- 클라이언트에서 "렉이 걸린 것 같다"는 느낌
- 아직 라이브 전이라 유저 불만은 없었지만, 선제적 대응 필요

---

## 문제 분석

### 기존 구조

```
클라이언트 요청 → DB 읽기 → 비즈니스 로직 → DB 쓰기 → 응답
```

문제점:
- **모든 요청마다 DB 접근** (읽기 + 쓰기)
- 요청당 평균 **50ms** 소요
- 컨텐츠가 늘어날수록 쿼리 복잡도 증가

### 병목 지점

프로파일링 결과:
- 비즈니스 로직: ~5ms
- **DB 읽기/쓰기: ~45ms** ← 병목

---

## 해결 방안

### 핵심 아이디어

> "자주 읽는 데이터는 메모리에, DB 동기화는 일정 주기로"

### 인메모리 트랜잭션 구조

```
세션 시작 → 메모리에 유저 데이터 로드 → 메모리에서 처리 → 주기적 DB 동기화
```

```go
type UserSession struct {
    userData  *UserData      // 메모리에 캐싱
    dirty     bool           // 변경 여부
    lastSync  time.Time      // 마지막 동기화 시간
}

func (s *UserSession) UpdateInventory(itemId int, qty int) {
    s.userData.Inventory[itemId] += qty
    s.dirty = true  // DB 쓰기는 나중에
}
```

### Write-back 동기화

```go
// 일정 주기마다 변경된 데이터만 DB에 반영
func SyncWorker() {
    for session := range activeSessions {
        if session.dirty && time.Since(session.lastSync) > syncInterval {
            db.Save(session.userData)
            session.dirty = false
            session.lastSync = time.Now()
        }
    }
}
```

### 데이터 정합성 보장

1. **세션 종료 시 강제 동기화**: 유저 로그아웃 시 즉시 DB 반영
2. **중요 트랜잭션 즉시 반영**: 결제 등 크리티컬한 작업은 바로 DB 저장
3. **서버 종료 시 전체 플러시**: graceful shutdown으로 데이터 손실 방지

---

## 결과

### 성능 개선

| 지표 | Before | After | 개선 |
|-----|--------|-------|------|
| 평균 응답 시간 | 50ms | 5ms | **10배** |
| DB 쓰기 횟수 | 요청마다 | 주기적 | **90% 감소** |

### 부가 효과

- **DB 부하 감소**: 쓰기 요청 대폭 감소
- **확장성 향상**: 동시 접속자 증가에도 안정적
- **라이브 전 선제 대응**: 런칭 후 성능 이슈 없음

---

## 트레이드오프

### 장점
- 응답 속도 대폭 개선
- DB 부하 감소

### 주의점
- 메모리 사용량 증가
- 서버 장애 시 동기화되지 않은 데이터 손실 가능

### 대응
- 동기화 주기 튜닝 (너무 길지 않게)
- 중요 데이터는 즉시 동기화
- 서버 이중화 및 graceful shutdown

---

## 배운 점

1. **성능 문제는 라이브 전에 발견하는 게 최선**
   - 라이브 후 발견하면 핫픽스 압박

2. **"매번 DB"는 안티패턴이 될 수 있다**
   - 읽기가 잦은 데이터는 캐싱 필수

3. **Write-back은 데이터 정합성과 트레이드오프**
   - 중요도에 따라 즉시 반영 vs 지연 반영 구분 필요
