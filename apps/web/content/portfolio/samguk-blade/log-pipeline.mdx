---
title: "로그 파이프라인 재설계"
description: "스키마리스 구조로 로그 작업 생산성 4배 향상"
project: "samguk-blade"
projectTitle: "삼국 블레이드 키우기"
tags: ["Architecture", "Logging", "DX"]
order: 3
---

## TL;DR

이전 프로젝트에서 로그 하나 추가하는 데 0.5일이 걸리는 비효율을 경험했습니다. **스키마리스 구조**로 파이프라인을 재설계하여, 구조체 정의만으로 로그 발송이 가능하게 만들었고, 작업 시간을 **0.5일 → 1시간**으로 4배 단축했습니다.

---

## 배경

이전 프로젝트(BladeX)에서 로그 추가 작업이 병목이었습니다.

### 기존 프로세스 (BladeX)

```
1. SQL 테이블 정의 (DBA 협의)
2. C++ 코드에서 테이블 연동
3. 비즈니스 로직에서 로그 발송
4. 테스트 및 검증
```

**총 소요 시간: 약 0.5일**

문제점:
- 실제 로그를 남기는 "비즈니스 로직 작성"보다 **스키마/연동 작업에 시간이 더 소요**
- 새 로그 타입마다 테이블 추가 필요
- 스키마 변경 시 마이그레이션 필요

---

## 문제 정의

```
로그 추가 요청 → 스키마 정의 → 코드 연동 → 테스트 = 0.5일
```

핵심 문제:
1. **스키마 종속성**: 로그 구조가 DB 테이블에 종속
2. **연동 오버헤드**: 매번 DB 연결 코드 작성
3. **유연성 부족**: 필드 추가/변경 시 마이그레이션 필요

---

## 해결 방안

### 핵심 아이디어

> "로그는 애플리케이션 레벨에서 구조체 정의만으로 발송 가능해야 한다"

### 스키마리스 구조

AWS Kinesis + 스키마리스 저장소(예: S3, Elasticsearch)를 활용했습니다.

```go
// 구조체 정의만으로 로그 타입 추가 가능
type ItemPurchaseLog struct {
    LogBase
    ItemID    int    `json:"item_id"`
    Quantity  int    `json:"quantity"`
    Price     int    `json:"price"`
    Currency  string `json:"currency"`
}

// 사용
logger.Send(&ItemPurchaseLog{
    ItemID:   123,
    Quantity: 1,
    Price:    1000,
    Currency: "KRW",
})
```

### 새로운 프로세스

```
1. Go 구조체 정의 (5분)
2. 비즈니스 로직에서 로그 발송 (30분)
3. 테스트 (25분)
```

**총 소요 시간: 약 1시간**

### 공통 로그 베이스

모든 로그에 자동으로 포함되는 공통 필드:

```go
type LogBase struct {
    LogType     string    `json:"log_type"`
    Timestamp   time.Time `json:"timestamp"`
    UserID      int64     `json:"user_id"`
    SessionID   string    `json:"session_id"`
    RequestID   string    `json:"request_id"`  // CS 대응용
    ServerID    string    `json:"server_id"`
}
```

---

## 결과

### 작업 시간 비교

| 단계 | Before (BladeX) | After |
|-----|----------------|-------|
| 스키마 정의 | 2시간 | 5분 (구조체) |
| 코드 연동 | 1시간 | 0분 (자동) |
| 비즈니스 로직 | 30분 | 30분 |
| 테스트 | 30분 | 25분 |
| **총합** | **4시간 (0.5일)** | **1시간** |

**작업 생산성 4배 향상**

### 부가 효과

1. **일 1천만 건 로그 안정 발송**
   - AWS Kinesis Producer로 배치 처리
   - 재시도 로직으로 메시지 유실 방지

2. **CS 대응 효율화**
   - RequestID로 행위 흐름 추적 가능
   - 운영팀이 개발자 없이 문제 파악

---

## CS 대응 로그 설계

### 요청 ID 기반 추적

하나의 유저 액션에서 발생하는 모든 로그에 동일한 RequestID를 부여했습니다.

```
[RequestID: abc-123]
1. 상품 구매 요청
2. 재화 차감 (-1000 gold)
3. 아이템 추가 (+1 sword)
4. 우편 발송 (구매 영수증)
5. 퀘스트 진행 (구매 1회 달성)
```

### 결과

운영 담당자가 운영툴 대시보드에서:
1. 유저 ID로 검색
2. RequestID로 그룹핑된 로그 확인
3. **개발자 개입 없이 CS 처리**

---

## 배운 점

1. **DX(개발자 경험)가 생산성을 결정한다**
   - 로그 추가가 쉬우면 더 많은 로그를 남기게 됨
   - 더 많은 로그 = 더 나은 디버깅

2. **스키마는 때로는 족쇄가 된다**
   - 로그처럼 유연해야 하는 데이터는 스키마리스가 적합

3. **운영 효율화는 설계 단계에서 고려해야 한다**
   - RequestID 같은 설계는 나중에 추가하기 어려움
