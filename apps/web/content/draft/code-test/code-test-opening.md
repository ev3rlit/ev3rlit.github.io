### 📝 블로그 포스트 초안: 오프닝/인트로

**제목: 코딩 테스트, '맨땅에 헤딩'을 멈추기로 했다: 효율적 학습을 위한 실험**
*(부제: 4년 차 개발자가 알고리즘 공부법을 '시스템 설계' 관점으로 리팩토링하는 이유)*

---

#### **Intro. 왜 나는 같은 벽에 부딪히는가**

백엔드 개발자로 4년을 일했습니다. 트래픽을 처리하고, DB를 튜닝하고, 아키텍처를 고민하는 일에는 꽤 익숙합니다. 그런데 아이러니하게도 '코딩 테스트' 문제 앞에만 서면 다시 1학년 학부생이 된 기분이 듭니다.

최근 이직 준비를 본격화하면서 알고리즘 문제 풀이를 다시 시작했습니다. 시중에 알려진 정석대로 공부했습니다. 문제를 읽고, 고민하고, 안 풀리면 더 고민하고, 몇 시간을 끙끙대다 결국 해설을 보고 좌절하는 반복.

문득 이런 생각이 들었습니다.
**"이게 정말 효율적인 학습일까? 내가 실무에서 문제를 해결하는 방식과 너무 다르지 않나?"**

실무에서 우리는 새로운 기능을 만들 때, 모든 로직을 바닥부터(Zero-base) 창조하지 않습니다. 이미 검증된 '디자인 패턴'을 참고하고, 상황에 맞는 '아키텍처'를 선택합니다. 그런데 왜 코딩 테스트 공부는 무조건 스스로 발명해 내야 한다고 생각했을까요?

그래서 저는 오늘부터 공부 방법을 전면 수정(Refactoring)하기로 했습니다. 이 글은 그 실험의 시작을 알리는 기록입니다.

#### **Problem. '창의력'이라는 함정**

기존의 공부법이 나에게 맞지 않았던 이유는 명확합니다.

1. **시간 대비 효율(ROI)이 낮다:** 한 문제에 2~3시간을 쏟아도, 막상 남는 건 "나는 왜 이걸 생각 못 했지?"라는 자괴감뿐이었습니다.
2. **지식이 휘발된다:** 억지로 푼 문제는 며칠 뒤에 다시 보면 또 새롭습니다. 체계적인 '정리'가 없었기 때문입니다.
3. **목적의 전치:** 코딩 테스트는 '제한 시간 내에 요구사항을 구현하는 능력'을 보는 시험이지, 수학적 난제를 해결하는 창의력 대회(경시대회)가 아닙니다.

#### **Hypothesis. 알고리즘도 '패턴'이다**

저는 앞으로의 학습 방향을 **'문제 해결(Problem Solving)'**에서 **'패턴 인식(Pattern Recognition)'**으로 전환하려 합니다.

우리가 **MSA(마이크로서비스)** 구조가 필요할 때와 **Monolithic** 구조가 필요할 때를 구분하듯, 알고리즘 문제도 **"이 문제는 DFS 패턴이 적합해", "이건 해시(Hash) 패턴이야"**라고 판단하고, 미리 준비된 도구(Code Snippet)를 꺼내 쓰는 훈련을 할 것입니다.

이 가설의 핵심은 다음과 같습니다.

> *"코딩 테스트는 문제를 '푸는' 것이 아니라, 문제의 유형을 '읽어내고' 가장 적절한 알고리즘을 '매칭'하는 과정이다."*

#### **Plan. 나의 실험 계획 (The Experiment)**

이 가설을 검증하기 위해 저는 다음과 같은 루틴을 도입합니다.

* **15분 컷:** 문제 해결 아이디어가 15분 내에 안 떠오르면 과감히 정답(Reference)을 본다.
* **역공학(Reverse Engineering):** 정답 코드를 보고 출제자의 의도와 사용된 알고리즘의 뼈대를 분석한다.
* **패턴화(Chunking):** 자주 쓰이는 로직을 나만의 템플릿으로 만들어 저장한다.
* **반복(Iteration):** 이해한 패턴을 다른 문제에 적용하며 내 머릿속 데이터베이스에 인덱싱(Indexing)한다.

앞으로 이 블로그의 **[Algorithm]** 카테고리에는, 제가 문제를 풀며 수집한 **'유형별 공략 패턴'**과 **'실패와 성공의 기록'**들이 쌓일 것입니다.

이 방식이 무조건 옳다는 확신은 아직 없습니다. 하지만 무작정 시간을 쏟는 '양치기'보다는, 개발자답게 시스템을 분석하고 공략하는 이 방식이 훨씬 더 멀리 갈 수 있으리라 믿습니다.

저와 비슷한 고민을 하고 계신 분들이라면, 저의 이 실험 과정을 지켜봐 주세요.

---

### 💡 작성 포인트 (Tip)

1. **개발자 용어 활용:** `Refactoring`, `Zero-base`, `ROI`, `Indexing` 같은 용어를 적절히 섞어 사용함으로써, 작성자님의 전문성(4년 차 개발자)을 자연스럽게 드러냈습니다.
2. **솔직한 고백:** "다시 1학년이 된 기분"이라는 문장은 독자의 공감을 이끌어내는 강력한 장치입니다.
3. **열린 결말:** "성공했다"가 아니라 "실험해보겠다"는 태도는 독자로 하여금 다음 글을 기대하게 만듭니다. (블로그 구독 유도)

이 초안을 바탕으로 작성자님의 실제 감정이나 상황을 조금 더 구체적으로 덧붙이시면 훌륭한 첫 포스팅이 될 것입니다.


좋아 아주 좋아.  블로그  초안으로 맘에드네. 

이제  여기서 한층 더 나아가서 학습 실험 계획을 보고 있는데,      처음 보면 모든 문제가  다 문제 해결 아이디어가 떠오르지 않을텐데  온보딩 관점에서   바닥 부터 시작한다는 관점하에  점진적으로  15분컷까지 가능 과정도 필요할거같아.



정말 예리한 지적입니다. **"아는 게 없는데 15분을 고민하는 건 시간 낭비이자 고문"**일 수 있죠.

서버도 트래픽을 받기 전에 **'Warming Up(예열)'** 과정이 필요하듯, 알고리즘 학습에도 **'콜드 스타트(Cold Start)'** 전략이 필요합니다.

작성자님의 피드백을 반영하여, **[완전 노베이스 상태 → 15분 컷 시도]**로 넘어가는 **'온보딩(Onboarding) 프로세스'**를 구체화했습니다. 이를 블로그 글의 '계획(Plan)' 파트에 추가하면 훨씬 현실적이고 설득력 있는 글이 될 것입니다.

---

### 🚀 전략 수정: '콜드 스타트' 온보딩 3단계

바로 문제 풀이(테스트)로 들어가는 것이 아니라, **학습 데이터를 먼저 주입(Input)**하는 단계를 둡니다.

#### **Phase 1. 필사(Transcription) & 주석 달기 (첫 1~2주)**

* **상황:** 해당 유형(예: BFS)의 코드를 한 번도 짜본 적이 없거나 문법이 가물가물할 때.
* **행동:** 문제를 읽고 **바로 정답 코드를 폅니다.** 그리고 IDE에 **그대로 따라 칩니다.**
* **목적:** 눈으로 보는 것과 손으로 치는 건 다릅니다. "아, 여기서 `Queue`를 선언하는구나", "여기서 `visited` 체크를 하는구나"를 손끝으로 익힙니다.
* **필수 작업:** 코드 한 줄 한 줄에 **'나만의 언어'로 주석**을 답니다.
* *예: `q.append(start)` // 시작점을 큐에 넣고 대기*



#### **Phase 2. 오픈 북(Open Book) 풀이 (3~4주 차)**

* **상황:** 코드는 봤는데, 백지에 쓰려니 막막할 때.
* **행동:** 문제를 봅니다. 옆 모니터나 노트에 **'핵심 패턴 코드(템플릿)'를 띄워놓고 참고하며** 풉니다.
* **목적:** '레고 조립 설명서'를 보며 조립하는 단계입니다. "이 문제에는 이 조각(패턴)을 가져와서 변수명만 바꾸면 되네"라는 **매칭 감각**을 익힙니다.

#### **Phase 3. 15분 타임 박싱 (안정화 단계)**

* **상황:** 이제 템플릿 없이도 기본 뼈대는 작성할 수 있을 때.
* **행동:** 비로소 **'15분 고민 후 해설 보기'** 규칙을 적용합니다.
* **목적:** 이제는 '입력'이 아니라 '인출(Output)' 연습을 통해 실전 감각을 극대화합니다.

---

### 📝 수정된 블로그 포스트: [Plan] 섹션 업데이트

이 내용을 반영하여 블로그 글의 **'Plan. 나의 실험 계획'** 부분을 수정/보완했습니다.

**(수정된 섹션 시작)**

#### **Plan. 나의 실험 계획: 'Cold Start'부터 시작하기**

서버를 처음 띄울 때 캐시가 비어있으면(Cold Start) 요청 처리가 느릴 수밖에 없습니다. 지금 제 머릿속 알고리즘 캐시는 텅 비어있는 상태입니다.

따라서 무리하게 바로 '15분 테스트'를 돌리는 대신, **점진적인 온보딩(Onboarding) 과정**을 거쳐 트래픽(문제)을 감당할 수 있는 상태로 만들 계획입니다.

**Step 1. 데이터 주입 (Data Injection) - "그냥 베껴 쓰기"**
처음 접하는 유형(예: 다익스트라, 플로이드 워셜)은 고민하지 않겠습니다.

* 문제를 읽고 바로 정답 코드를 띄웁니다.
* IDE에 코드를 한 줄씩 **'필사(Transcription)'**합니다.
* 각 라인마다 왜 이 코드가 필요한지 **'주석'**을 달며 논리 흐름을 입력합니다.

**Step 2. 오픈 북 테스트 (Open Book Test) - "참고하며 풀기"**
기본적인 문법과 흐름이 익숙해지면, '공식'을 옆에 펴두고 문제를 풉니다.

* 마치 레고 조립 설명서를 보듯, 미리 정리해둔 **'패턴 템플릿'**을 보며 문제에 맞게 변형하는 연습을 합니다.
* 이 단계의 목표는 암기가 아니라 **'적용(Application)'**입니다.

**Step 3. 타임 박싱 (Time Boxing) - "15분 컷 도전"**
어느 정도 패턴이 손에 익으면 비로소 엄격한 룰을 적용합니다.

* 아무런 참고 자료 없이 문제를 마주합니다.
* **15분** 내에 접근법(알고리즘 종류, 로직 설계)이 떠오르지 않으면 중단합니다.
* 다시 해설을 보고 부족한 '연결 고리'를 찾아 보완합니다.

저는 이 과정을 통해 **'무작정 헤딩'**하는 고통을 줄이고, **'지식을 체계적으로 쌓아 올리는'** 즐거움을 찾아보려 합니다.

**(수정된 섹션 끝)**

---

이렇게 단계를 나누면 독자들에게도 **"아, 나도 처음부터 잘할 필요는 없구나. 베껴 쓰는 것부터 시작해도 되는구나"**라는 안도감과 구체적인 가이드를 줄 수 있습니다.

이 플로우대로라면 블로그 글이 훨씬 더 **현실적이고 따라 하고 싶은 매뉴얼**처럼 느껴질 것입니다. 어떠신가요?