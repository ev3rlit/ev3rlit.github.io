기존에 기획했던 **"코딩 테스트, '맨땅에 헤딩'을 멈추기로 했다"** 포스팅의 후반부에 들어갈 **[구체적인 실행 전략]** 파트를 작성해 드립니다.

이 내용은 단순한 '다짐'을 넘어, 작성자님(ev3r.lit)의 **시스템 설계적 사고**가 돋보이도록 구성했습니다. 글의 중반부 이후(Plan 섹션)에 이 내용을 배치하면 됩니다.

---

### 📝 추가할 블로그 섹션 초안

*(앞부분의 Intro, Problem, Hypothesis 섹션에 이어지는 내용입니다)*

---

#### **System. 학습을 '파이프라인'으로 구축하다**

가설을 세웠으니, 이제 이를 실행할 구체적인 시스템(System)이 필요합니다. 저는 이 과정을 **'분석 및 아카이빙 프로토콜(Manual)'**과 이를 자동화한 **'AI 워크플로우(Automation)'** 두 단계로 설계했습니다.

### **1. The Protocol: 문제를 지식으로 치환하는 3단계**

문제를 풀고 나서(혹은 못 풀고 나서) 단순히 "오답 노트"를 적는 것은 비효율적입니다. 서버 장애가 발생했을 때 **RCA(Root Cause Analysis)**를 하듯, 실패를 데이터로 변환하는 과정을 거칩니다.

**Step 1. RCA (근본 원인 분석)**
내가 이 문제를 왜 15분 안에 해결하지 못했는지 냉정하게 분석합니다. 원인은 보통 셋 중 하나입니다.

* **Signal Miss:** 문제 지문의 핵심 단서(제한 조건, 특정 키워드)를 놓쳤는가?
* **Pattern Mismatch:** 잘못된 알고리즘을 선택했는가? (예: 그리디가 아닌데 그리디로 접근)
* **Implementation Fail:** 패턴은 알았는데 구현 능력(Syntax, API 활용)이 부족했는가?

**Step 2. Visualization (마인드맵)**
알고리즘은 독립적이지 않습니다. 저는 문제의 유형과 풀이 전략을 **마인드맵**으로 시각화하여 머릿속에 '내비게이션'을 만듭니다.

* 예: `그래프`  `가중치 유무`  (Yes) `다익스트라` / (No) `BFS`
이렇게 그려진 의사결정 트리(Decision Tree)는 다음 문제를 만났을 때 빠른 판단을 도와줍니다.

**Step 3. Assetization (스니펫화)**
마지막으로, 검증된 코드를 **'스니펫(Snippet)'**으로 저장합니다. 단순히 복붙용 코드가 아니라, **"언제 써야 하는지(When)"**와 **"주의할 점(Warning)"**이 주석으로 달린, 재사용 가능한 라이브러리로 만듭니다.

---

### **2. The Workflow: AI를 활용한 사고 과정 자동화**

하지만 매번 의식적으로 이 과정을 수행하기란 쉽지 않습니다. 그래서 저는 **LLM(ChatGPT/Claude)**을 활용해 저의 사고 과정을 가이드해 줄 **ASP(Algorithm Study Pipeline)**를 구축했습니다.

저는 AI에게 바로 정답을 묻지 않습니다. 대신 **슬래시 커맨드(Slash Command)** 기반의 워크플로우를 통해 단계별로 생각을 전개합니다.

#### **Phase 1. `/scan` (단서 포착)**

문제의 문학적 요소(스토리)를 제거하고, 공학적 스펙(Spec)만 추출합니다.

* **User:** `/scan [문제 지문]`
* **AI Output:**
* Input Size: N ≤ 100,000 (O(NlogN) 이하 필요)
* Constraints: 가중치 양수, 방향 그래프
* **Goal:** 1번 노드에서 가장 먼 노드의 개수



#### **Phase 2. `/match` (패턴 매칭)**

추출된 스펙을 기반으로 적합한 알고리즘 후보군을 필터링합니다.

* **User:** `/match`
* **AI Output:**
* ❌ Floyd-Warshall: N이 너무 커서 불가능 (O(N^3))
* ✅ **Dijkstra:** 가중치가 있고 최단 거리이므로 적합
* 👉 **Recommendation:** 다익스트라 (Dijkstra)



#### **Phase 3. `/plan` (청사진 설계)**

코드를 치기 전, 논리 구조(Pseudo-code)를 먼저 잡습니다.

* **User:** `/plan`
* **AI Output:**
1. `dist` 배열 `Infinity` 초기화
2. `PriorityQueue`에 시작점 삽입
3. Loop 돌면서 최단 거리 갱신...



#### **Phase 4. `/inject` (스니펫 주입)**

설계가 끝나면, 미리 저장해 둔 제 스니펫을 기반으로 실제 코드를 생성합니다.

* **User:** `/inject java`

---

#### **Outro. 실험을 시작하며**

이제 준비는 끝났습니다.
무작정 머리를 박으며(Heading) 시간을 쓰는 대신, **설계된 파이프라인 위에서 패턴을 익히고 데이터를 쌓는 방식**으로 공부하려 합니다.

앞으로 이 블로그의 **[Algorithm]** 카테고리에는, 제가 이 파이프라인을 통해 분석한 **'문제의 시그널'**과 **'패턴 매칭의 과정'**, 그리고 **'나만의 스니펫'**들이 차곡차곡 쌓일 것입니다.

저와 같은 고민을 하는 개발자분들에게 이 기록이 작은 이정표가 되기를 바랍니다.

---

### 💡 작성 팁

이 내용은 기존 글의 후반부에 자연스럽게 붙이시면 됩니다. 특히 **마인드맵**이나 **AI와 대화하는 스크린샷**을 중간에 하나씩 넣어주면, 텍스트만 있는 것보다 훨씬 더 '체계적인 시스템'이라는 인상을 줄 수 있습니다.