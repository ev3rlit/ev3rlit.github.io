# 포트폴리오 작성을 위한 준비 체크리스트

삼국블레이드키우기 포트폴리오 컨텐츠를 보강하기 위해 필요한 자료 목록입니다.

---

## 1. 코드 레포지토리에서 추출할 것

### 1.1 에러 핸들링 시스템

- [ ] `errs.Wrap()` 또는 에러 래핑 함수 구현체
- [ ] 에러 컨텍스트 수집 구조체 (Context, ErrorInfo 등)
- [ ] 에러 코드 정의 (에러 타입별 분류가 있다면)
- [ ] 클라이언트 에러 응답 변환 로직 (`toClientError` 등)

### 1.2 미들웨어 코드

- [ ] 에러 핸들링 미들웨어
- [ ] 요청/응답 로깅 미들웨어
- [ ] 리커버리 미들웨어 (panic 처리)
- [ ] 트랜잭션 미들웨어
- [ ] 미들웨어 체인 구성 코드

### 1.3 인메모리 트랜잭션 / 캐싱

- [ ] 유저 세션 구조체 (`UserSession` 또는 유사한 것)
- [ ] Write-back 동기화 워커/고루틴 코드
- [ ] Graceful shutdown 시 데이터 플러시 로직
- [ ] 중요 트랜잭션 즉시 반영 로직 (결제 등)

### 1.4 로그 파이프라인

- [ ] LogBase 구조체 (공통 로그 필드)
- [ ] 각종 로그 타입 구조체 예시 2~3개
- [ ] AWS Kinesis Producer 연동 코드
- [ ] 배치 처리 및 재시도 로직
- [ ] RequestID 생성/전파 로직

### 1.5 API / 라우팅

- [ ] API 라우터 등록 코드 (전체 API 목록 파악용)
- [ ] WebSocket 핸들러 구조
- [ ] RPC 메시지 포맷 정의

### 1.6 길드 시스템 (CQRS 관련)

- [ ] Command 핸들러 예시
- [ ] Query 핸들러 예시
- [ ] 이벤트 소싱 관련 코드 (있다면)
- [ ] 길드 상태 관리 구조체

### 1.7 통합 매출 조회 시스템 + 무중단 스키마 마이그레이션 ⭐

> **배경**:
> - 개발 단계에서 퍼블리셔가 영수증 수집 API + 매출 대시보드를 제공
> - 우리는 영수증 원본(base64)만 DB에 저장 (퍼블리셔가 매출 통계를 다 해주니까)
> - **퍼블리셔 계약 해지 → 자체 서비스 전환**
> - 자체 운영툴에 매출 조회 기능 필요 → 매출 집계에 필요한 필수 정보(통화코드, 가격, 트랜잭션ID 등)가 없음
> - 글로벌 서비스라 원화 환산이 안 되는 문제

#### Before (기존 구조)
- [ ] 기존 영수증 저장 구조 (base64만 저장하던 코드/스키마)
- [ ] 어떤 필드들이 누락되어 있었는지 명확히

#### After (개선 구조)
- [ ] **플랫폼별 테이블 3개** 스키마/구조체
  - [ ] `appstore` 테이블 - Apple 고유 정보
  - [ ] `galaxy` 테이블 - Samsung 고유 정보
  - [ ] `playstore` 테이블 - Google 고유 정보
- [ ] **transaction_index 테이블** 스키마/구조체
  - [ ] 공통 필드: transaction_id, 통화코드, 가격, 플랫폼, 원화환산가격 등
  - [ ] 매출 조회용 인덱스 구성

#### 무중단 마이그레이션 과정
- [ ] 백그라운드 프로세스 코드 (기존 데이터 가공/채워넣기)
  - [ ] 기존 영수증 base64에서 필요한 정보 파싱 로직
  - [ ] 새 테이블에 데이터 삽입 로직
- [ ] 배포 전/후 처리 로직
  - [ ] 배포 전: 백그라운드로 기존 데이터 마이그레이션
  - [ ] 배포 후: 신규 결제부터 새 구조로 기록
- [ ] 마이그레이션 검증 방법 (데이터 정합성 체크)

#### 결과
- [ ] 마이그레이션된 레코드 수
- [ ] 다운타임 없이 완료했다는 증거
- [ ] 매출 조회 기능 동작 확인 (스크린샷 등)

### 1.8 3사 스토어 서비스 이관 작업 ⭐

> **배경**: 퍼블리셔 계약 해지 후 퍼블리셔가 지원하던 모든 기능을 자체 관리로 전환

#### 퍼블리셔가 지원하던 것 → 자체 전환 항목

- [ ] **인증/로그인 시스템**
  - [ ] 퍼블리셔 SDK → 자체 인증으로 전환한 내용
  - [ ] 기존 유저 계정 마이그레이션 방법

- [ ] **결제 시스템 (IAP)**
  - [ ] App Store 영수증 검증 직접 구현
  - [ ] Play Store 영수증 검증 직접 구현
  - [ ] Galaxy Store 영수증 검증 직접 구현
  - [ ] 각 스토어별 API 연동 코드

- [ ] **푸시 알림**
  - [ ] 퍼블리셔 푸시 → 자체 푸시 시스템 전환 (있다면)

- [ ] **매출 통계/대시보드**
  - [ ] 위에서 다룬 통합 매출 조회 시스템

- [ ] **유저 데이터 분석**
  - [ ] 퍼블리셔 분석툴 → 자체 로그 파이프라인으로 대체

- [ ] **기타 퍼블리셔 의존성**
  - [ ] 그 외 전환한 항목들 (있다면 추가)

#### 이관 과정

- [ ] 전체 이관 일정/타임라인
- [ ] 이관 중 서비스 다운타임 있었는지?
- [ ] 기존 유저 데이터 보존 방법
- [ ] 스토어별 앱 이관 절차 (앱 ID, 인증서 등)

#### Apple 계정 이관 - 장애 대응 경험 ⭐⭐ (핵심 스토리)

> **상황**:
> - Apple OAuth는 개인정보 보호 정책으로 이관 대상에서 제외됨
> - 별도 Transfer API를 통한 이관 필요
> - [TVING 팀 앱 이관 여행기](https://medium.com/tving-team/%EC%95%A0%ED%94%8C-%EC%95%B1-%EC%9D%B4%EA%B4%80-%EC%97%AC%ED%96%89%EA%B8%B0-e0bdfae8da67) 문서 참고하여 진행
> - 기존 유저들이 자연스럽게 새 서비스 계정으로 연결될 것으로 예상
>
> **문제 발생**:
> - 서비스 이관 신청 → pending 기간(2일) 종료 후
> - **기존 서비스 계정으로 로그인하던 모든 Apple 유저 접속 불가** (장애 상황)
> - 예상과 달리 자동 연결이 되지 않음
>
> **긴급 대응**:
> - Sign in with Apple 일시 중단
> - 이전 서비스 계정 토큰 → 새 서비스 계정으로 일괄 전환
>
> **대응 방식 선택 (의사결정)**:
> - 실시간 대응: 과거/현재 OAuth 둘 다 지원 → 코드 변경 + 배포 필요
> - 배치 대응: 현재 OAuth만 유지, 기존 토큰 일괄 마이그레이션
> - **배치 방식 선택**: 이미 현재 OAuth로만 로그인되도록 배포된 상태였기 때문
>
> **결과**:
> - 복구까지 **약 1일 소요**
> - 영향 범위: 기존 Apple 계정 로그인 유저 전체

- [ ] Transfer API 연동 코드
- [ ] 토큰 일괄 전환 스크립트/코드
- [ ] 장애 발생 ~ 복구 타임라인 상세 (언제 인지, 언제 대응 시작, 언제 복구)
- [ ] 영향받은 유저 수 (대략적인 수치)
- [ ] 복구 후 검증 방법
- [ ] TVING 문서와 실제 상황이 달랐던 점 (왜 자동 연결이 안 됐는지)

#### 결과

- [ ] 이관 완료까지 소요 기간
- [ ] 이관 후 서비스 안정화 과정
- [ ] 이관 과정에서 배운 점

### 1.9 프로젝트 구조

- [ ] 전체 디렉토리 트리 (`tree` 명령어 결과)
- [ ] 주요 패키지별 역할 설명 (간단히)

---

## 2. 커밋 히스토리에서 찾을 것

### 2.1 핵심 기능 도입 커밋

- [ ] 에러 핸들링 시스템 최초 도입 커밋
- [ ] 인메모리 트랜잭션 구조 도입 커밋
- [ ] 로그 파이프라인 재설계 커밋
- [ ] CQRS 패턴 도입 커밋
- [ ] **결제 스키마 마이그레이션 관련 커밋들** ⭐
  - [ ] transaction_index 테이블 추가 커밋
  - [ ] 백그라운드 마이그레이션 스크립트 커밋
  - [ ] 신규 결제 로직 적용 커밋
- [ ] **3사 스토어 이관 관련 커밋들** ⭐
  - [ ] 자체 인증 시스템 구현 커밋
  - [ ] 각 스토어별 영수증 검증 구현 커밋
  - [ ] 기존 유저 마이그레이션 커밋

### 2.2 문제 해결 커밋

- [ ] 성능 개선 관련 커밋 (DB 레이턴시 등)
- [ ] 버그 수정 커밋 중 인상적인 것
- [ ] 장애 대응 관련 커밋 (있다면)

### 2.3 통계

- [ ] 총 커밋 수
- [ ] 본인 커밋 비율 (기여도 파악)
- [ ] 프로젝트 기간 동안의 커밋 빈도

---

## 3. 기획서에서 확인할 것

### 3.1 프로젝트 규모

- [ ] 전체 컨텐츠/시스템 목록
  - 예: 인벤토리, 상점, 길드, 랭킹, 우편, 퀘스트, 가챠 등
- [ ] 각 시스템별 API 개수 (대략적으로)
- [ ] 데이터 모델 구조 (유저 데이터에 어떤 정보가 있는지)

### 3.2 런칭/운영 정보

- [ ] 정식 런칭일
- [ ] 서비스 플랫폼 (Google Play, App Store, Galaxy Store)
- [ ] 퍼블리셔 이관 시점 및 상세 내역

---

## 4. 운영 지표 (공개 가능한 범위에서)

### 4.1 트래픽 관련

- [ ] DAU (일일 활성 사용자) - 대략적인 범위라도
- [ ] 피크 타임 동시 접속자 수
- [ ] 일일 API 요청 수

### 4.2 로그/데이터 관련

- [ ] 일일 로그 발생량 (1천만 건의 근거)
- [ ] DB 데이터 크기 (대략)

### 4.3 운영 지표

- [ ] 평균 핫픽스 대응 시간 (개선 전/후)
- [ ] CS 처리 건수 및 개발자 개입 비율 변화

---

## 5. 본인 기여도 명확화

### 5.1 직접 설계/구현한 것 ✅ (대부분 답변 완료)

- [x] **에러 핸들링 시스템**: 본인 전담
  - 라이브러리 탐색 → 도입 → 팀원 온보딩까지 전 과정

- [x] **미들웨어 아키텍처**: 본인 전담
  - REST API 서버 미들웨어 구현
  - 웹소켓용 인터셉터 구현 (gRPC 용어 차용)
  - CTO가 만든 RPC 컨트롤러를 위한 인터셉터 구조 + 각종 인터셉터 구현

- [x] **인메모리 트랜잭션**: 협업
  - 초기 제안: 본인
  - 유지보수 + 확장성 개선: CTO
  - CTO 구현: API 요청 전후 Entity 비교 → MongoDB update bson operation 생성 → 클라이언트 전송 동기화
  - 자체 개발이라 버그 다수 → **유지보수 주로 본인 담당**

- [x] **로그 파이프라인**: 애플리케이션 레벨 본인 전담
  - 로그 스키마 설계 가이드
  - 로그 발송 High Level API
  - 로그 배치 수집 및 발송 처리
  - Kinesis SDK 연동 (퍼블리셔 제공 인프라)

- [x] **CI/CD 파이프라인**: 협업
  - 초기 구축: 본부장님 지원
  - 유지보수: 본인

- [x] **결제 스키마 마이그레이션**: 본인 전담
  - 인게임 재화 상품 구매 기능 개발
  - 인앱결제 상품 구매 기능 개발
  - 영수증 원본 DB 보관 로직
  - 퍼블리셔 영수증 API 연동 (상세내역 발송)
  - → 위 전체를 개발했기에 마이그레이션도 본인 담당

- [x] **3사 스토어 이관**: 인증, 결제 담당 (본인 확인됨)
  - Apple Transfer API 연동 + 장애 대응
  - 각 스토어별 영수증 검증 구현

### 5.2 협업 내용

- [ ] 클라이언트 개발자와의 협업 방식
- [ ] 기획자와의 협업 방식
- [ ] 운영팀과의 협업 방식

---

## 6. 추가 컨텍스트

### 6.1 팀 구성 ✅ (답변 완료)

- **전체 팀 규모**: 약 15명 (아트팀은 별도 분리)
- **개발자**: 7명
  - 서버 개발자: 2명 (본인 포함) + CTO 기술 지원
  - 클라이언트 개발자: 5명
- **기획자**: 약 6명 (정확하지 않음)

**역할 상세**:
- 본인: 서버 핵심 개발 담당 (아키텍처, 인프라, 핵심 시스템)
- 다른 서버 개발자 1명: 포지션은 서버였으나 실제로는 클라이언트 코어 작업 담당
- 다른 개발자들: 비즈니스 로직 및 게임 컨텐츠 구현에 집중

> **포트폴리오 표현 수정 필요**:
> - 현재 about.mdx: "팀 내 유일한 서버 개발자"
> - ✅ 수정: "서버 아키텍처 및 핵심 시스템 담당자"

### 6.2 기술 선택 이유 ✅ (답변 완료)

#### Golang 선택 이유
- **배경**: CTO가 사내 신규 프로젝트에 Golang 도입 추진 중, 합류 시 이미 프로토타이핑 진행 중
- **회사 상황**: 서버 프로그래머 적고 클라이언트 프로그래머 다수 → 클라이언트 개발자도 백엔드 비즈니스 로직 작업 필요
- **Golang의 장점**:
  - 언어 학습 곡선 낮음 (클라이언트 개발자 온보딩 용이)
  - 동시성 처리 (goroutine)로 퍼포먼스 확보
  - 코드 생산성 좋음
- **기존 인프라**: 인증 서버, 웨어하우스 서버, 랭킹 집계 서버가 이미 Golang으로 구성

#### MongoDB 선택 이유
- **핵심**: 애플리케이션 레벨에서 DB 스키마 관리 가능
- **기술적 장점**:
  - NoSQL/Document 기반 → Golang 구조체와 호환성 높음
  - 스키마 변경 시 마이그레이션 부담 적음
- **회사 상황 적합**: 비즈니스 로직이 그대로 DB에 반영되어야 하는 인력 구조에 맞음

#### WebSocket + RPC 선택 이유
- **배경**: 사내 기존 프로젝트들이 TCP 소켓 + RPC 형태 사용
- **전환 과정**: 소켓 → 웹소켓으로 변경 (웹 기반 구조로 전환)
- **RPC 유지 이유**: REST API 경험 부재, 익숙한 RPC 패턴 도입
- **결과**: 기존 개발자들의 학습 비용 최소화

### 6.3 프로젝트 타임라인

```
[ ] 2023.04 - 프로젝트 시작
[ ] ______ - 핵심 시스템 완성
[ ] ______ - 알파/베타 테스트
[ ] ______ - 정식 런칭
[ ] 2025.02 - 원유니버스 이관
[ ] 2025.10 - 서비스 종료? or 현재 진행중?
```

### 6.4 어려웠던 점 / 실패 경험

- [x] **BladeX 실패 사례: 아이템 결과 불일치 문제** ✅

  **문제 상황**
  - 유저가 아이템 사용 시 결과 팝업과 실제 획득 재화가 다르게 표시
  - 신규 아이템 업데이트 후 일정 시간 뒤 CS 인입으로 문제 인지
  - 원인: 실제 처리 결과가 아닌 **시뮬레이션 결과**를 응답으로 보내고 있었음

  **BladeX에서 개선하지 못한 이유 (아키텍처적 한계)**
  - 인메모리 레벨에서 유저 데이터 관리했으나 **트랜잭션 기능 없음**
  - 처리 도중 실패 시 **롤백 불가능**
  - 그래서 시뮬레이션으로 사전 검증 → 통과 시 처리하는 방식 채택
  - 문제점:
    - 확률적 보상: 시뮬레이션 결과 ≠ 실제 처리 결과 (확률이 다시 돌아감)
    - 여러 아이템 소모 시에도 시뮬레이션 의존

  **삼국블레이드에서의 개선**
  1. **트랜잭션 + 롤백 구조를 초기 설계에 포함**
  2. 시뮬레이션 기능 과감히 제거
  3. 에러 발생 시 즉각 롤백 → 무결성 보장
  4. 아이템 처리 과정을 컨텍스트에 보관 → 전체 처리 결과 반환
  5. 모든 아이템 처리는 단 하나의 함수만 통과하도록 설계 → 로직 분기 방지

  ```go
  receipts, err := itemService.AddItem(ctx, itemKey, itemCount, opts...)
  return receipts.ToItems()
  ```

  **교훈**: 트랜잭션/롤백 없이는 "보여주는 것"과 "실제 처리"를 일치시키기 어려움

- [x] **삼국블레이드 개발 중 가장 어려웠던 문제** ✅

  **1. 서버 설계 경험 부족**
  - BladeX에서는 서버 코어 없이 컨텐츠/비즈니스 로직만 개발
  - 처음부터 서버 설계 및 필요한 기능을 어디서부터 시작해야 할지 막막
  - → 게임서버가 아닌 타 백엔드 개발자들의 아키텍처 설계 방법 공부

  **2. 인메모리 트랜잭션 버그**
  - 개발 단계 + 라이브 서비스 중에도 계속 새로운 유형의 버그 발생
  - 개발자마다 데이터 스키마 정의 방식, 활용 방식이 달라 엣지 케이스 다수
  - → 날 잡고 유닛 테스트 코드 작성하여 엣지 케이스 검증

  **3. 클라이언트 개발자 설득**
  - 서버에 새 기능 추가 시 클라이언트 프로그래머에게 왜 필요한지 설명하기 어려움

- [x] **해결하지 못하고 남은 기술 부채** ✅

  **1. RPC 배치 요청 미지원**
  - 자체 RPC 구조가 한 번에 여러 요청 보내기 불가
  - 라이브 중 특정 페이지 API 수 증가 → 네트워크 라운드트립으로 클라이언트 렉 발생

  **2. 실시간 모니터링 부재**
  - pprof 프로파일링 가능했으나 사전 모니터링 없음
  - 문제 발생 시 수동으로 pprof 활성화 → 배포 → go tool로 수집 → 분석
  - 운영툴에서 실시간 성능 병목 수집했으면 선제 대응 가능했을 것

  **3. 에러 로그 집계 부재**
  - 에러 로그가 콘솔 출력 → 프로세스별로 grep으로 확인
  - 중앙 집계 시스템 있었으면 시스템 에러 대응 더 쉬웠을 것

  **4. 피처 토글 부재**
  - 특정 서비스 문제 발생 시 해당 기능만 정지 불가능
  - 게임 경제 인플레이션/유저 재화 손해 상황에서 빠른 대응 어려움
  - 피처 토글 있었으면 피해 최소화 + 복구 시간 단축 가능

  **5. 게임 데이터 무결성**
  - 엑셀 파일로 게임 데이터 정의 + 자체 직렬화 포맷/역직렬화 코드 자동생성
  - 데이터 정합성/외래키 보장 기능 없음 → 정적 데이터 무결성 깨짐 빈번
  - 엑셀 파일 간 관계 설정 어려움 + 기획자 휴먼 에러 문제

- [x] **퍼블리셔 해지 후 자체 서비스 전환 대응** ✅
  - 퍼블리셔 의존 → 자체 서비스로 급하게 전환된 상황
  - 서비스 중 마이그레이션의 어려움/리스크
  - 교훈: 외부 의존성 있더라도 핵심 데이터는 자체 관리 필요

---

## 7. 포트폴리오에 추가할 상세 컨텐츠 후보

현재 3개 (에러 핸들링, DB 레이턴시, 로그 파이프라인)가 상세 페이지로 작성되어 있습니다.
추가로 상세 페이지를 만들 만한 주제:

- [ ] **CQRS 길드 시스템**: 패턴 적용 과정, 동시성 처리
- [ ] **통합 매출 조회 시스템 + 무중단 마이그레이션** ⭐ (추천)
  - 퍼블리셔 해지 → 자체 서비스 전환 → 서비스 중 스키마 마이그레이션 → 다운타임 없이 해결
  - 글로벌 서비스 환경에서 멀티 플랫폼 결제 통합 (App Store, Play Store, Galaxy Store)
- [ ] **3사 스토어 서비스 이관** ⭐ (추천)
  - 퍼블리셔 의존 → 완전 자체 서비스로 전환
  - 인증, 결제 전면 재구축
  - 기존 유저 데이터 보존하며 이관
- [ ] **Apple 계정 이관 장애 대응** ⭐⭐ (강력 추천)
  - 레퍼런스 없는 상황에서 문제 해결
  - 서비스 장애 → 긴급 대응 → 토큰 일괄 전환
  - "예상치 못한 상황에서의 문제 해결 능력" 어필
- [ ] **WebSocket + RPC 실시간 통신**: 프로토콜 설계
- [ ] **미들웨어 아키텍처**: 150개+ API 일원화 관리
- [ ] **CI/CD 파이프라인**: Jenkins 자동화 구성

---

## 우선순위 가이드

### 필수 (꼭 준비해주세요)

1. 핵심 코드 스니펫 (에러 핸들링, 미들웨어, 로그)
2. 수치의 근거 (성능 개선 전/후 측정 데이터)
3. 프로젝트 디렉토리 구조

### 권장 (있으면 좋음)

4. 커밋 히스토리 주요 내역
5. 운영 지표
6. 기술 선택 이유

### 선택 (여유가 있다면)

7. 추가 상세 컨텐츠 (CQRS, 매출 시스템 등)
8. 실패 경험 / 기술 부채

---

## 파일 공유 방법

준비가 되시면 다음 방법 중 편한 것으로 공유해주세요:

1. **코드 레포지토리**: GitHub/GitLab 링크 또는 로컬 경로
2. **기획서**: PDF, Word, 노션 링크 등
3. **스크린샷**: 운영 대시보드, 지표 화면 등

---

*이 파일에 체크표시(✅)를 하면서 준비 상황을 트래킹하시면 됩니다.*
